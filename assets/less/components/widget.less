.s-widget {
    
    /* BEGIN backwards compat -- these variables existed when this file was last worked on,
     * but have been removed in the meantime. */
    @su-16: 16px;
    @su-12: 12px;
    @su-8: 8px;
    @su-4: 4px;
    @br-2: 2px;
    @fs-12: 12px;
    @fs-11: 11px;
    @forest: #64A05E;
    @forest-100: lighten(@forest,40%);   // #dfecde
    @forest-200: lighten(@forest,30%);   // #c1d9be
    @forest-300: lighten(@forest,20%);   // #a2c69e
    /* END backwards compat */

    
    @s-widget-content-padding: @su-16 - 1px; // subtract 1px for border
    @s-widget-content-inner-spacing: @su-12; // the spacing between two adjacent simple items
    @s-widget-content-outer-spacing: @su-16; // the spacing at the start/end of a group of simple items, as well as between a complex item and its separator line

    @s-widget-outer-border-color: @black-100;
    @s-widget-content-separator-color: @black-075;
    @s-widget-header-background-color: @black-025;

    @s-widget-outer-border-color-blue: @powder-200;
    @s-widget-content-separator-color-blue: @powder-200;
    @s-widget-header-background-color-blue: darken(@powder,5%); // would be @powder-150 if that existed
    @s-widget-content-background-color-blue: @powder-100;

    @s-widget-outer-border-color-yellow: @yellow-300;
    @s-widget-content-separator-color-yellow: @yellow-300;
    @s-widget-header-background-color-yellow: darken(@yellow,5%); // would be @yellow-150 if that existed
    @s-widget-content-background-color-yellow: @yellow-100;

    @s-widget-outer-border-color-green: @forest-300;
    @s-widget-content-separator-color-green: @forest-200;
    @s-widget-header-background-color-green: lighten(@forest,35%); // would be @forest-150 if that existed
    @s-widget-content-background-color-green: @forest-100;

    border: 1px solid @s-widget-outer-border-color;
    border-radius: @br-2;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    font-size: 13px; // TODO: 13px isn't in our size list
    
    a, a:visited {
        color: @black-500;
    }
    
    .-header, .-content {
        display: block;
    }
    
    .-header {
        font-size: 15px; // TODO: 15px isn't in our size list
        font-weight: normal;
        color: @black-500;
        padding: @su-12 @su-16;
        background: @s-widget-header-background-color;
        border-bottom: 1px solid @s-widget-content-separator-color;
        
        &._alternate-small-bold {
            font-size: @fs-12;
            font-weight: bold;
            .-action {
                line-height: 1.3*@fs-12;  // line-height should be the same as in the outside element, so the header and action baselines line up
                font-weight: normal;
            }
        }
        
        .-action {
            font-size: @fs-11;
            color: @blue;
            float: right;
            margin: 0 0 @su-4 @su-8;
            line-height: 1.3*15px; // line-height should be the same as in the outside element, so the header and action baselines line up
        }
        
    }
    .-content + .-header {
        // TODO: handle the collapsed case
        border-top: 1px solid @s-widget-content-separator-color;

        // This will collapse with the previous content element's bottom margin.
        // In particular this means this relies on the fact that the outer spacing
        // is larger than the inner spacing.
        margin-top: @s-widget-content-outer-spacing;
    }

    .-header + .-content, .-content:first-child { // (1)
        margin-top: @s-widget-content-outer-spacing;
    }
    .-content:last-child {
        margin-bottom: @s-widget-content-outer-spacing;
    }    
    
    &._complex-items {

        // In a complex widget, we must support things like collapsible (in particular invisble)
        // elements. Therefore we cannot rely on things like :first-child, because the *first*
        // child may not be the first *visible* child. This is why in a complex widget, every
        // header and item has a border-top. But because you shouldn't see the first visible
        // item's or header's top border (the widget itself provides for that border), we shift
        // everything up by one pixel with the following pseudo-element.
        &:before {
            content: '';
            display: block;
            margin-top: -1px;
        }
        
        // However, because of the above, the top item's divider line now sits above the .s-widget's top
        // border. We could fix this by using overflow: hidden, but that would constrain users of
        // .s-widget to never have things like tooltips, autocompletes or the like that reach outside
        // the widget boundaries.
        // What we do instead is re-create the widget's top border in an absolutely positioned :after,
        // which sits above our item's top border. Technically, a tiny corner of the item's border will
        // still be visible, but at its highest point, this corner has a height of 0.27 pixels. Also,
        // we're recreating part of the rounded border that would technically be covered by the non-rounded
        // item, but that's at most 0.13 pixels. And for both of these sub-pixel issues, we're talking
        // about different shades of gray. So we can live with all of that.
        &:after {
            content: '';
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            height: 1px + @br-2; // we need 1px border + 2px border radius to have the correct corner shape
            border-top: 1px solid @s-widget-outer-border-color;
            border-radius: @br-2;
            pointer-events: none; // if the top item is clickable, then we don't want to prevent clicking the top 2 pixels
        }
        
        position: relative; // so that it's the positioning parent for the :after
        
        .-content {
            border-top: 1px solid @s-widget-content-separator-color;
            padding-top: @s-widget-content-outer-spacing;
            padding-bottom: @s-widget-content-outer-spacing;
            margin: 0;
        }
        .-header {
            border-bottom: none; // in a ._complex-items widget, the items provide the border
            border-top: 1px solid @s-widget-content-separator-color;
            &._collapsing-control {
                cursor: pointer;
                &:before {
                    content: '';
                    float: left;
                    margin-right: @su-12;
                    border: 5px solid transparent;
                    border-right-width: 0;
                    border-left-color: @black-200;
                    margin-top: ~"calc(1.3em / 2 - 5px)"; // 1.3 is our standard line height
                    transition: transform 0.3s cubic-bezier(0.4, 0.4, 0.6, 1);
                }
                &[aria-expanded='true']:before {
                    transform: rotate(90deg);
                }
            }
        }
        .-content + .-header {
            margin-top: 0;
        }
    }
    .-content {
        
        position: relative; //TODO comment (or move to parent?)
        
        & {
            margin-bottom: @s-widget-content-inner-spacing;
            // note that the first content element after a header (or if there's no header at all)
            // also needs a top margin; this is handled further above (see "(1)")
        }
        padding: 0 @s-widget-content-padding;
        
        &.is-current {
            &:before {
                content: '';
                position: absolute;
                height: ~"calc(100% +" @s-widget-content-inner-spacing ~")";
                left: 0;
                border-left: 3px solid @orange;
                margin-left: -1px; // the orange selection indicator overlaps with the widget border
                margin-top: -@s-widget-content-inner-spacing/2;
            }
            font-weight: bold;
        }
    }
    
    // see http://stackoverflow.com/a/43965099 for how this works:
    // TODO: this is very generic, so it probably shouldn't just be used for s-widget
    
    // Notes on the clip-path stuff: What we would really like is overflow: hidden during the transition,
    // but not when the element is expanded. Unfortunately, although the CSS spec provides for it, there's
    // no browser support yet for transitioning non-interpolatable properties, and therefore we cannot say
    // "change overflow to visible *after* the transition".
    //
    // So we use clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%), which is essentially the same
    // as overflow: hidden, but unlike overflow, clip-path is interpolatable -- but only if the opposite state
    // is also a polygon, and has the same vertice count. So our version of overflow: visible is a rectangle
    // of 2x2 million pixels, which should be enough for everybody (TM).
    //
    // At the time of writing, clip-path works in Chrome, Firefox Beta, and Safari (with vendor prefix).
    //
    // In browsers that do not support this yet, we have to have another way to prevent the collapsible content
    // from being visible below the bottom edge during the transition, and the best I could come up with is
    // transitioning to scaleY(0) with a timing function that's faster than the height-reducing transitions.
    // This does kinda look like a deliberate effect, even more so if we also transition to transparency
    // (which we therefore do), so I feel it's an okay fallback.
    .-collapsible-group-wrapper {
        @dur: 0.3s;

        display: flex;

        clip-path: polygon(-1000000px -1000000px, 1000000px -1000000px, 1000000px 1000000px, -1000000px 1000000px);
        -webkit-clip-path: polygon(-1000000px -1000000px, 1000000px -1000000px, 1000000px 1000000px, -1000000px 1000000px);
        transition: clip-path 0s @dur, -webkit-clip-path 0s @dur;

        &:after {
            content: '';
            height: 50px;
            transition: height @dur linear, max-height 0s @dur linear;
            max-height: 0px;
            flex-basis: 0;
        }
        .-collapsible-group {
            transition: margin-bottom @dur cubic-bezier(0, 0, 0, 1), transform @dur cubic-bezier(1, 0, 1, 1),  opacity @dur cubic-bezier(1, 0, 1, 1);
            margin-bottom: 0;
            max-height: 1000000px;            
            flex-basis: 100%;
            transform-origin: 0 0;
        }
        &.is-collapsed {
            clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%);
            transition: none;
            .-collapsible-group {
                margin-bottom: -1500px;
                transition: margin-bottom @dur cubic-bezier(1, 0, 1, 1),
                            visibility 0s @dur, max-height 0s @dur, transform @dur cubic-bezier(0, 1, 1, 1), opacity @dur cubic-bezier(0, 1, 1, 1);
                visibility: hidden;
                max-height: 0;
                transform: scaleY(0);
                opacity: 0;
                @supports (clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)) or (-webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 100%, 0% 100%)){
                    transform: none;
                    opacity: 1;
                }
            }
            &:after {
                height: 0;
                transition: height @dur linear;
                max-height: 50px;
            }
        }
    }
    
    // COLOR ALTERNATIVES
    // todo: use CSS custom properties for this once we don't care about IE anymore

    .alternate-color(blue);
    .alternate-color(yellow);
    .alternate-color(green);
    
    .alternate-color(@col) {
            
        &._alternate-@{col} {
            @border-col: "s-widget-outer-border-color-@{col}";
            @header-bg-col: "s-widget-header-background-color-@{col}";
            @content-bg-col: "s-widget-content-background-color-@{col}";
            @seperator-col: "s-widget-content-separator-color-@{col}";
            
            border-color: @@border-col;
            background-color: @@content-bg-col;
            &._complex-items .-content {
                border-color: @@seperator-col;
            }
            .-header, .-content + .-header {
                border-color: @@seperator-col;
                background-color: @@header-bg-col;
            }
        }
    }
    
   
    
    /*&:not(._complex-items) > :not(.-content):not(.-header) {
        .stacks-error('All children of a non-complex .s-widget must be .-content or .-header.');
    }*/
    
}
